import json
import os.path
import datetime
import pandas as pd

from odysseus.path_config.path_config import root_data_path
from odysseus.utils.geospatial_utils import *
from odysseus.utils.time_utils import *
from odysseus.utils.bookings_utils import *


from odysseus.city_data_manager.od_matrices.od_to_trips import *


def generate_week_config(
        week_slots_type,
        day_slots_type,
):

    """
    This function creates a nested dictionary called "week_config" containing the information to divide time
    into discrete slots. A number of pre-defined configurations are accessible by specifying the parameters
    "week_slots_type" and "day_slots_type".
    Alternatively, user can specify any custom configuration in a json file with the same structure of the
    dictionary generated by this function.
    """

    week_config = dict()

    if week_slots_type == "weekday_weekend":

        week_config["week_slots"] = dict()
        week_config["week_slots"]["weekday"] = [w for w in range(0, 6)]
        week_config["week_slots"]["weekend"] = [6, 7]
        week_config["day_slots"] = dict()
        week_config["day_slots"]["weekday"] = dict()
        week_config["day_slots"]["weekend"] = dict()

    if day_slots_type == "hours":

        for week_slot in week_config["week_slots"]:
            for h in range(24):
                week_config["day_slots"][week_slot][str(h)] = [h]
                week_config["day_slots"][week_slot][str(h)] = [h]

    if day_slots_type == "daymoments":

        for week_slot in week_config["week_slots"]:

            week_config["day_slots"][week_slot]["night"] = list()
            for h in range(6):
                week_config["day_slots"][week_slot]["night"].append(h)

            week_config["day_slots"][week_slot]["morning"] = list()
            for h in range(6, 12):
                week_config["day_slots"][week_slot]["morning"].append(h)

            week_config["day_slots"][week_slot]["afternoon"] = list()
            for h in range(12, 18):
                week_config["day_slots"][week_slot]["afternoon"].append(h)

            week_config["day_slots"][week_slot]["evening"] = list()
            for h in range(18, 24):
                week_config["day_slots"][week_slot]["evening"].append(h)

    return week_config


def generate_hourly_od_count_dict(week_config, zone_ids, how="uniform", **kwargs):

    """
    This function generates a nested dictionary containing hourly OD matrices.
    It is used only to generate commonly used, artificial OD matrices (e.g. uniform) for the purpose of testing.
    """

    hourly_od_count_dict = dict()
    if how == "uniform":
        for week_daytype in week_config["week_slots"].keys():
            hourly_od_count_dict[week_daytype] = {}
            for day_slot in week_config["day_slots"][week_daytype]:
                for hour in week_config["day_slots"][week_daytype][day_slot]:
                    hourly_od_count_dict[week_daytype][hour] = dict()
                    for origin in zone_ids:
                        hourly_od_count_dict[week_daytype][hour][origin] = {}
                        for destination in zone_ids:
                            hourly_od_count_dict[week_daytype][hour][origin][destination] = kwargs["count"]
    return hourly_od_count_dict


def get_hourly_od_from_count(
        hourly_count_dict, week_config, zone_ids, week_daytype, hour
):

    """
    Create hourly OD matrix dataframe from hourly_count_dict
    """

    od_df = pd.DataFrame()
    for origin in zone_ids:
        for destination in zone_ids:
            for day_slot in week_config["day_slots"][week_daytype]:
                if hour in week_config["day_slots"][week_daytype][day_slot]:
                    od_df.loc[origin, destination] = hourly_count_dict[week_daytype][hour][origin][destination]
    return od_df


def get_day_slot_od_from_count(
        hourly_count_dict, week_config, zone_ids, week_daytype, day_slot
):

    """
    Create OD matrix dataframe for a certain day slot from hourly_count_dict
    """

    od_df = pd.DataFrame()
    for origin in zone_ids:
        for destination in zone_ids:
            for hour in week_config["day_slots"][week_daytype][day_slot][:1]:
                od_df.loc[origin, destination] = hourly_count_dict[week_daytype][hour][origin][destination]
    return od_df


def generate_od_from_week_config(
        city_name,
        data_source_id,
        week_config,
        zone_ids,
        od_type,
        **kwargs
):

    """
    This function creates 2 dictionaries of pandas dataframes containing OD matrices which are generated according
    to a certain rule specified in the parameter "od_type".
    """

    od_matrices_by_dayslots = dict()
    od_matrices_by_hour = dict()
    for week_daytype in week_config["week_slots"].keys():
        od_matrices_by_dayslots[week_daytype] = dict()
        od_matrices_by_hour[week_daytype] = dict()
        for day_slot in week_config["day_slots"][week_daytype]:
            if od_type == "count":
                assert "hourly_od_count_dict" in kwargs
                od_matrices_by_dayslots[week_daytype][day_slot] = get_day_slot_od_from_count(
                    kwargs["hourly_od_count_dict"], week_config, zone_ids, week_daytype, day_slot
                )
                for hour in week_config["day_slots"][week_daytype][day_slot]:
                    od_matrices_by_hour[week_daytype][hour] = get_hourly_od_from_count(
                        kwargs["hourly_od_count_dict"], week_config, zone_ids, week_daytype, hour
                    )

    os.makedirs(os.path.join(root_data_path, city_name, "norm", "od_matrices", data_source_id, ), exist_ok=True)
    for week_slot in od_matrices_by_dayslots:
        for day_slot in od_matrices_by_dayslots[week_slot]:
            od_matrices_by_dayslots[week_slot][day_slot].to_csv(os.path.join(
                root_data_path, city_name, "norm", "od_matrices", data_source_id,
                "_".join([str(week_slot), str(day_slot)]) + ".csv"
            ))

    return od_matrices_by_dayslots, od_matrices_by_hour


week_config = generate_week_config(
    week_slots_type="weekday_weekend",
    day_slots_type="daymoments",
)
base_path = os.path.join(root_data_path, "my_city_3X3", "norm", "od_matrices", "my_data_source")
os.makedirs(base_path, exist_ok=True)
with open(os.path.join(base_path, "week_config.json"), "w") as f:
    json.dump(week_config, f, indent=4)

grid_config = {
    "cell_type": "square",
    "n_rows": 3,
    "n_cols": 3,
    "bin_side_length": 500
}

grid_matrix = get_city_grid_as_matrix(
    (0, 0, grid_config["n_cols"]*grid_config["bin_side_length"], grid_config["n_rows"]*grid_config["bin_side_length"]),
    grid_config["bin_side_length"],
    "dummy_crs"
)

zone_ids = np.ravel(grid_matrix.values)

hourly_od_count_dict = generate_hourly_od_count_dict(week_config, zone_ids, "uniform", count=3)

od_matrices_by_dayslots, od_matrices_by_hour = generate_od_from_week_config(
    city_name="my_city_3X3",
    data_source_id="my_data_source",
    week_config=week_config,
    zone_ids=zone_ids,
    od_type="count",
    hourly_od_count_dict=hourly_od_count_dict
)

generate_trips_from_od(
    "my_city_3X3",
    od_matrices_by_hour,
    grid_matrix,
    zone_ids,
    datetime.datetime(2023, 1, 1, 0, 0, 1),
    datetime.datetime(2023, 1, 8, 0, 0, 1),
    datetime.datetime(2023, 1, 8, 0, 0, 1),
    datetime.datetime(2023, 1, 15, 0, 0, 1),
)
